%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Structured General Purpose Assignment
% LaTeX Template
%
% This template has been downloaded from:
% http://www.latextemplates.com
%
% Original author:
% Ted Pavlic (http://www.tedpavlic.com)
%
% Note:
% The \lipsum[#] commands throughout this template generate dummy text
% to fill the template out. These commands should all be removed when 
% writing assignment content.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass{article}

\usepackage{fancyhdr} % Required for custom headers
\usepackage{lastpage} % Required to determine the last page for the footer
\usepackage{extramarks} % Required for headers and footers
\usepackage{graphicx} % Required to insert images
\usepackage{lipsum} % Used for inserting dummy 'Lorem ipsum' text into the template

%------------------------------------------added package by MOHO
%\usepackage{comment} % Comment
\usepackage{verbatim} %comment package
\usepackage[utf8]{inputenc} 
\usepackage{url} % URL in Footnote  ??? 
\usepackage{cite} % BibLatex
\usepackage[table]{xcolor}
\usepackage{csquotes} %Quotation




% Margins
\topmargin=-0.45in
\evensidemargin=0in
\oddsidemargin=0in
\textwidth=6.5in
\textheight=9.0in
\headsep=0.25in 

\linespread{1.1} % Line spacing

% Set up the header and footer
\pagestyle{fancy}
\lhead{\hmwkAuthorName} % Top left header
\chead{\hmwkClass\ (\hmwkClassInstructor): \hmwkTitle} % Top center header
\rhead{\firstxmark} % Top right header
\lfoot{\lastxmark} % Bottom left footer
\cfoot{} % Bottom center footer
\rfoot{Page\ \thepage\ of\ \pageref{LastPage}} % Bottom right footer
\renewcommand\headrulewidth{0.4pt} % Size of the header rule
\renewcommand\footrulewidth{0.4pt} % Size of the footer rule

\setlength\parindent{0pt} % Removes all indentation from paragraphs

% Table Code Added by Ifetayo
\usepackage{tabulary}
\usepackage{fixltx2e}
\usepackage{tabularx}
\newcommand{\head}[1]{\textnormal{\textbf{#1}}}
%----------------------------------------------------------------------------------------
%	DOCUMENT STRUCTURE COMMANDS
%	Skip this unless you know what you're doing
%----------------------------------------------------------------------------------------

% Header and footer for when a page split occurs within a problem environment
\newcommand{\enterProblemHeader}[1]{
\nobreak\extramarks{#1}{#1 continued on next page\ldots}\nobreak
\nobreak\extramarks{#1 (continued)}{#1 continued on next page\ldots}\nobreak
}

% Header and footer for when a page split occurs between problem environments
\newcommand{\exitProblemHeader}[1]{
\nobreak\extramarks{#1 (continued)}{#1 continued on next page\ldots}\nobreak
\nobreak\extramarks{#1}{}\nobreak
}

\setcounter{secnumdepth}{0} % Removes default section numbers
\newcounter{homeworkProblemCounter} % Creates a counter to keep track of the number of problems

\newcommand{\homeworkProblemName}{}
\newenvironment{homeworkProblem}[1][Problem \arabic{homeworkProblemCounter}]{ % Makes a new environment called homeworkProblem which takes 1 argument (custom name) but the default is "Problem #"
\stepcounter{homeworkProblemCounter} % Increase counter for number of problems
\renewcommand{\homeworkProblemName}{#1} % Assign \homeworkProblemName the name of the problem
\section{\homeworkProblemName} % Make a section in the document with the custom problem count
\enterProblemHeader{\homeworkProblemName} % Header and footer within the environment
}{
\exitProblemHeader{\homeworkProblemName} % Header and footer after the environment
}

\newcommand{\problemAnswer}[1]{ % Defines the problem answer command with the content as the only argument
\noindent\framebox[\columnwidth][c]{\begin{minipage}{0.98\columnwidth}#1\end{minipage}} % Makes the box around the problem answer and puts the content inside
}

\newcommand{\homeworkSectionName}{}
\newenvironment{homeworkSection}[1]{ % New environment for sections within homework problems, takes 1 argument - the name of the section
\renewcommand{\homeworkSectionName}{#1} % Assign \homeworkSectionName to the name of the section from the environment argument
\subsection{\homeworkSectionName} % Make a subsection with the custom name of the subsection
\enterProblemHeader{\homeworkProblemName\ [\homeworkSectionName]} % Header and footer within the environment
}{
\enterProblemHeader{\homeworkProblemName} % Header and footer after the environment
}
   
%----------------------------------------------------------------------------------------
%	NAME AND CLASS SECTION
%----------------------------------------------------------------------------------------

\newcommand{\hmwkTitle}{Assignment\ \#1} % Assignment title
\newcommand{\hmwkDueDate}{Wednesday,\ February\ 18,\ 2015} % Due date
\newcommand{\hmwkClass}{M24} % Course/class
%\newcommand{\hmwkClassTime}{10:30am} % Class/lecture time
\newcommand{\hmwkClassInstructor}{Ben Mora} % Teacher/lecturer
\newcommand{\hmwkAuthorName}{SwanTech} % Your name

%----------------------------------------------------------------------------------------
%	TITLE PAGE
%----------------------------------------------------------------------------------------

\title{
\vspace{2in}
\textmd{\textbf{\hmwkClass:\ \hmwkTitle}}\\
\normalsize\vspace{0.1in}\small{Due\ on\ \hmwkDueDate}\\
\vspace{0.1in}\large{\textit{\hmwkClassInstructor}}
\vspace{3in}
}

\author{\textbf{\hmwkAuthorName}}
\date{} % Insert date here if you want it to appear below your name

%----------------------------------------------------------------------------------------

\begin{document}

\maketitle

%----------------------------------------------------------------------------------------
%	TABLE OF CONTENTS
%----------------------------------------------------------------------------------------

%\setcounter{tocdepth}{1} % Uncomment this line if you don't want subsections listed in the ToC

\newpage
\tableofcontents
\newpage
\section{Team Organisation and Collaboration}
\subsection{Team Name}
The team agreed unanimously to \textbf{SwanTech} as our team / company name.

We will use Java package name \textbf{com.swantech} in all Java classes.


\subsection{Team Organisation}
The M24 module 2015 has only 4 people attending, but 5 roles are identified in the lecture notes, so we have to split one role. The roles assigned are:\\

\begin{tabular}{ |l|l| }   % BE CAREFUL this is <pipe><lower case l><pipe><lower case l ><pipe> , not 'lllll' as it looks but rather |l|l| !!!
 \hline
 Customer Interface Manager & Simon Hewitt  \\ 
 Design Manager & David Tacey  \\ 
 Implementation Manager & Ifetayo Agunbiade  \\ 
 Test Manager & Mohamad Khaleqi \\
 Planning and Quality Manager  (PQM)& \textit{split between team members:}\\
 PQM - Team management & David Tacey\\
 PQM - Version Control and Code Inspections & Simon Hewitt\\
 PQM - Code Documentation & Ifetayo Agunbiade\\
 PQM - Coded Quality & Mohamad Khaleqi \\
 \hline
\end{tabular}\\

The team will meet formally each Monday at 15:00, in the Computer Science lab at Faraday 206, and will meet informally to check progress after the Wednesday lectures.
\\
Ifetayo is investigating team time management tools that support work breakdown and delivery timelines (WBS and Gantt chart capabilities are needed). This will be an online tool allowing all team members to share and update progress.

\subsection {Team Collaboration}
The team will collaborate informally through a Facebook group, which has now been set up. Formal documents that are part of the development and delivery will be maintained in GitHub, chosen for its strong team collaboration  capabilities, version control and multi-platform support.

%----------------------------------------------------------------------------------------
\newpage
\subsection{Team Role : Customer Interface Manager}

Simon Hewitt will be the Customer Interface Manager, as defined in the lecture slides "Team Roles and Group Work"
From the lecture notes, 
the Customer Interface Manager is responsible for:
\begin{enumerate}
  \item The team's relationship with it's customers
  \item Resolving ambiguities in requirements specifications
\end{enumerate}

To do this I propose the following actions and deliverables:
\begin{itemize}
\item Schedule regular meetings with the customers:- Ben Mora and Bob Laramee, to be agreed with them
\item Create populate and manage a user requirements document
\item Ensure non-functional requirements meet customer expectations
\item Create and manage the assumptions and issues list in the project control structure
\item Ensure the team has understanding of the requirements through formal requirements specification reviews
\item And ensure team understands requirements by informal discussions at team meetings
\item Review the designs to ensure they meet the requirements
\item Review the test plans and test cases to ensure user requirements are tested and validated
\item Responsible for managing each stage sign-off, ensuring the team deliverables meet the requirements and the customer accepts these deliverables as fit for purpose
\end{itemize}
As we will be following a RAD approach rather than a traditional waterfall, the requirements document will not be signed off and frozen, but will be the guide for each RAD development cycle. The requirements specification will be updated as necessary from feedback from RAD delivery and review. We believe that allowing the customer to see, use and give feedback on developing work ensures that we are on track to deliver what is really needed rather that what was written down (with the possible ambiguities that can arise from the complex process of documenting requirements). Furthermore, this RAD approach enables the development team to propose improvements and design alternatives that may deliver a better product.
\\
\\
We will investigate  requirement documentation alternatives over the next 14 days. This can range from an Excel spreadsheet to high cost , high complexity commercial offerings designed for huge teams and multi year projects. We will be looking for small scale, preferably open source solutions. 
\newpage
\subsection{Team Role : Design Manager}
\newpage
\subsection{Team Role : Implementation Manager}
This is role is to be handled by Ifetayo Agunbiade. Based on careful requirements and specification analysis of a given task or project implementation of the project features can commence. The responsibilities tied to this role deals with the implementation and project management strategies the company applies to building products that meet the requirements of the client. 
\subsubsection{Responsibilities}
\begin{itemize}
\item
Make sure there is adequate information about the project specification and software requirements
\item
Engage all team members in designing a decisive plan for writing of the program code
\item
Make sure all team members adhere to the coding and documentation conventions \cite{bobs3cs}
\item
Engage every team member in coming up with technical solutions
\item
Engaging every team member in identifying specification implementation
\item
Coordinating the team, assigning tasks and also making sure each team member has sufficient knowledge of how to go about implementation
\item
Liaise with the customer interface manager to make sure implementation and features development are in-line with the scope requirement and time schedule
\item
Engage team members in the assignment of sprint and tracking progress
\item
Determination of the time for deliverables. Development of a work schedule, work breakdown, and determining a date for completion
\item
Handling risk associated with failure of task completion
\end{itemize}
\subsubsection{Versioning}
A versioning scheme starting from 0.1 and incremented to 1.0 for the first release of the software, where 1.0 indicate final completion/release of the software. Code versioning would be managed with Git. The first product release would take the version 1.0. Project software is to be held in a repository, each project repository would have 4 main branches
\begin{itemize}
\item
Master Branch
\item
Testing Branch
\item
Development Branch
\item
Individual Developer Branch(es)
\end{itemize}
This would make it easy to identify development stages, apply bugs fixes without affecting already working code, separate development processes and code modularity by tasks, features and subsystems. Designing the repository in this way ensures that any change in the code follows a process and moves in one direction from features Development Stage to Testing Staging to Master (Production stage).
\subsubsection{Master Branch}
For the project the master branch represents the software in its production state containing the accepted features after it has gone through the development stages, technical reviews and integration testing. At every stage of the project implementation the master branch must always run and be void of defects or errors. The master branch is always to be stable and form a functional working software.
\subsubsection{Testing Branch}
This branch contains project software code that has gone through, and passed code reviews for conformance with the agreed features. Code in this branch is to be tested. At this stage all team members would review test codes, and apply changes as applicable. Once the code in this stage is approved it is merged to the master branch.
\subsubsection{Development Branch}
This branch contains code merged from the individual developer branch. Here the entire branch is checked for conformance with coding conventions, software development best practices and code documentation. Upon code reviews, this branch is pushed to the testing branch for further testing. For the code to advance from this stage all team members must review all codes, ensure adherence to coding conventions, best programming practices, and make sure the appropriate features have been implemented according to requirements.
\subsubsection{Individual Branch}
This branch may contain individual developer branch(es) of the project code. Each branch is to be cloned from the working Master branch (Production branch). Code push is done to the development staging branch for further review.
\subsubsection{Development Process}
Development paradigms like MVC and third party frameworks/libraries maybe used in-order to facilitate implementation. Adoption of such software development models or third party software would need to be used according to how they suit the given project. The software architecture and methodology to be followed in the implementation of the software are all subject to the agreed design specification. As with proper implementation, design comes first and implementation would be tailored according to the design approach. Development processes would take an iterative and incremental approach so as to accommodate any changes to the project requirements where frequent customer collaborations and input is seeked from time to time through the customer interface manager instead of having a closed implementation scheme where once the requirements are made available changes are difficult to make.

\subsubsection{Software Platform and Development Environment}
The Java version 7 or latest version would be used. Netbeans or eclipse would be used as the standard development environment.
\subsubsection{Coding and Documentation Convention}
Bob's Concise Coding Conventions is used as the coding convention to be followed in development \cite{bobs3cs}. Doxygen would be used in code documentation and the rules stated in Bob's Concise Introduction are to be followed.

\subsubsection{Deliverables Schedule}

\begin{tabular}{| p{0.5cm} | p{1.5cm} | p{5cm} | p {9cm}|}
\hline
  \head{S/N} & \head{Week} & \head{Tasks} & \head{Deliverables}\\
 \hline
 1 &  Week 1 & Identify all tasks and features required. Work break down. Identify objectives and feasibilities. Determine an architecture of implementation. Project development. & Methods/tools for monitoring implementation progress. Establishment of an implementation model to be followed. Sprints assigned to individual team members. Repository set-up. Java and git training plan if necessary. Plan for next week.\\
\hline
 2 &  Week 2 & Iteration of tasks from the week before. Development may be redefined to accommodate changes in the requirements & Progress report. Supplementary specifications (if any). Assessment of specification changes to delivery time, team source code and documentation review. Bug fixes. Deployment of finished features/tasks to master branch. Push working code to test staging environment for testing. Plan for next week\\
\hline
 3 &  Week 3 & Iteration of tasks from the week before. Development may be redefined to accommodate changes in the requirements & Team source code and documentation review. Progress report and possible risk assessment. Bug fixes. Push working code to test staging environment for testing.\\
\hline
 4 &  Week 4 & Integration phase & Team source code and documentation review. Progress report and possible risk assessment. Bug fixes. Push working code to test staging environment for testing. Plan for final deployment.\\
\hline
 5 &  Week 5 & Integration phase & Integration of the development branch to the testing branch. Source code and documentation review. Final deployment and test plans. Project sign off.\\
\hline
\end{tabular}

Assumptions like the number of weeks to be spent on the implementation is subjective to change. It might be longer or fast tracked to meet delivery time.
\subsubsection{Task and Risk Management}
After design, specification and requirements analysis, work would be distributed amongst team members. Sprints would be set-up using visual studio online TFS (Team Foundation Server) and Gnatt chart project planner as applicable. Visual reporting would be made available to each team member so they can track development progress and identify risks in terms of tasks not being completed as scheduled. In software development there is always a possibility of failure of some type of process so it is important every team member has access to information that helps identify, assess, and monitor progress of each development phase or feature. TFS provides online tools to help us manage time, help in planning and timely resolution of risks.

\newpage
\subsection{Team Role : Test Manager}
Test manager role will be \textit{Mohamad Khaleqi} responsibility. The test manager roles is a task with responsibility for the test effort's\footnote{Testing is the process of evaluating a system and the components to check if they are working correctly or not. Basically, it means to check the system to find errors, gaps, bugs and missing requirement or on the other words testing is a process of analysing a software to detect the difference between existing and required conditions.
} success. This role involves codes quality and codes testing. For test manager there are some roles:
\begin{itemize}
 \item understanding the testing by analyzing the project requirements.
 \item Organize the testing meeting.
 \item Develop the test plan.
 \item Arrange the software and hardware requirement for the test.
 \item Document all testing result and prepare a report.
 \item Communicate with team members.
\end{itemize}
In order to perform this role, I should:
\begin{itemize}
 \item Prepare Unit testing e.g. JUnit\footnote{Testing will not catch every error in the program, because it cannot evaluate every execution path in any but the most trivial programs. The same is true for unit testing. Additionally, unit testing by definition only tests the functionality of the units themselves. Therefore, it will not catch integration errors or broader system-level errors (such as functions performed across multiple units, or non-functional test areas such as performance). Unit testing should be done in conjunction with other software testing activities, as they can only show the presence or absence of particular errors; they cannot prove a complete absence of errors. In order to guarantee correct behavior for every execution path and every possible input, and ensure the absence of errors, other techniques are required, namely the application of formal methods to proving that a software component has no unexpected behavior.
}
 \item Integration testing\footnote{In some books it is called as Component testing.}There are two types of testing:
\begin{itemize}
\item Button-up integration testing. \\
begin with Unit testing and then moving to higher level combinations of units called modules or builds.
\item Top-Down integration testing.\\
In this test, first higher level modules are tested and then low level module. 
\end{itemize}
In developing software process, usually Button-up integration test happens first and then Top-Down integration test.~\cite{sommerville2009software}

 \item Software testing (Testing and debugging)
 \item Black Box and white Box
 \item Alpha and Beta testing
 \item Regression testing
 \item Ensure the team has understanding of the testing methods and also terms in testing unit. 
\end{itemize}

\begin{comment}
Software testing is a combinatorial problem. For example, every boolean decision statement requires at least two tests: one with an outcome of "true" and one with an outcome of "false". As a result, for every line of code written, programmers often need 3 to 5 lines of test code.\cite{myers2011art} This obviously takes time and its investment may not be worth the effort. There are also many problems that cannot easily be tested at all – for example those that are nondeterministic or involve multiple threads. In addition, code for a unit test is likely to be at least as buggy as the code it is testing. 
\end{comment}



\newpage
\subsection{Team Role : Planning and Quality Manager}

\subsubsection{PQM - Team Management}
As stated in the implementation stage, project and team management would be done using the tools TFS and gnatt charts. These tools would give a visual report on progress made by each team member. Allocation of task sprints and risk management would be facilitated with the use of the said tools.
\subsubsection{PQM - Version Control and Code Inspection}
This part will be handled by Simon Hewitt. Version Control is managed by GitHub, so I will ensure the team understand GitHub and how to use it, that they properly use check-out and check-in. I will have control over final deliverable versions, and managing branch merging.
Code inspection will be peer review across the group. I will investigate mark up tools. The MicroSoft Word document review tools are a powerful tool for team review, I will seek something similar for plain-text code files. 
\subsubsection{PQM - Code Documentation}
This part will be handled by Ifetayo Agunbiade. Here all implementation code are checked that they are properly documented. Doxygen would be used in code documentation generation.
\subsubsection{PQM - Code Quality}
This part will be handled by Mohamad Khaleqi. In order to check the code quality in Java, First I will use Eclipse IDE because of automatic code indentation and auto formatting. Then I will make sure the code is following Bob's Concise Coding Conventions and also Doxygen. In addition to have better and tidy code, I will use CodePro Analytix \footnote{CodePro Analytix is the premier Java software testing tool for Eclipse developers who are concerned about improving software quality and reducing developments costs and schedules. More info: \url{https://developers.google.com/java-dev-tools/codepro/doc/}} and PMD\footnote{ PMD is a source code analyzer. It finds common programming flaws like unused variables, empty catch blocks, unnecessary object creation, and so forth.More info: \url{http://pmd.sourceforge.net/}} which they are both Eclipse plugins. They are both perfectly fine with any problem in the code and both are compatible with Java code. For code quality I will use LTFCE definition. The code over its lifetime will be read many more times than written. So, good code is: 
\begin{itemize}
 \item \textbf{L}egible: Only the code(Not comment) should clearly state the indent and reader should easily make sense of the code.
 \item \textbf{T}estable: The could will be in the way that unit tester can do its job.
 \item \textbf{F}lexible: Dependencies, both on other code in the code base and arbitrary implementation choices, should be minimized.
 \item \textbf{C}omplaint: The code itself should be correct and meet the system requirements.
 \item \textbf{E}conomical: The code should be responsible in terms of using system resources e.g. memory and CPU.
 
\end{itemize}

\begin{comment}
Legible - The code (the code itself, not comments) should clearly state the intent. If the reader can not make sense of the code, than all other efforts are doomed to frustration if not outright failure.

Testable - The code should be organized in a way that facilitates unit testing. That supports all subsequent efforts (refactoring for modification, correction of defects, revision due to changed specs, etc.)

Flexible - Dependencies, both on other code in the code base and arbitrary implementation choices, should be minimized. Hard-coded assumptions about data size, concrete classes or data structures, etc. make the code more brittle, and therefore harder to reuse or adapt.

Compliant - The code should comply with its requirements, functional and otherwise. (I don't state this as "correct" because the discussion about whether the requirements themselves were the "right" requirements is about the process or the environment, not about the code.)

Economical - The code should make reasonable use of system resources: memory, CPU, etc. (I don't state this as "efficient" because that word is too often misused, by limiting it to a single aspect, such as speed. Economy is simply about return on investment, and requires thought about all the resources being invested and all the measures of return.)

The point of insisting that these be considered in order is that each property supports the ones that follow. For example, defects (failure to comply with specs) in code which is legible, testable, and flexible can probably be corrected with reasonable effort. On the other hand, I suspect that every programmer has had experience with code which was micro-optimized for performance to the point that it was too brittle for reasonable maintenance.

\end{comment}


%----------------------------------------------------------------------------------------
\newpage
\section{Schedule, Format and Quality}
After searching for suitable document templates, we believe the attached document from the Swiss Federal Institute of Technology, Zurich, provides and excellent template. It is in MicroSoft Word format, so we will reformat into LaTeX, taking the opportunity to omit sections that are not relevant and ensure it fits our needs. This answers the question on format, and contains the necessary guidance on quality management as well. 

\footnote{se.inf.ethz.ch/old/.../Project Plan wo QA, Transition.doc}
\subsection{Initial Schedule of Work}

When we receive the project requirements on 18/2/15, the initial actions are:

\begin{itemize}
  \item Arrange a team meeting as soon as possible to review the document
  \item Set up and populate an open issues register, add all open questions to the register (Simon)
  \item Initial decomposition into work domains, arranged by team strengths as far as possible
  \item Create a first draft WBS \footnote{Work Breakdown Structure, a simple way to manage deliverables in a project (http://en.wikipedia.org/wiki/Work\_breakdown\_structure)} structure and assign names and target dates to each work package.
  \item Customer Interface Manager (SH) to arrange meeting(s) with Ben Mora to resolve all open questions.
  \item Test Manager (MK) to create outline test plan, showing what elements will be tested by which techniques, and setting up any necessary infrastructure.
  \item Design Manager (DT) to create high level design
  \item Implementation Manager (IA) to create high level implementation plan, and take ownership and manage the WBS schedule.
\end{itemize}
All of these actions to be completed by Monday 2 March 2015.
\newpage
\section{Environment}

It is assumed that the project will be developed in Java.
\\
The team members use different desktop OS including Linux, OS X and Windows, so tools must support each of these. We have agreements or working assumptions or proposals for all identified software components:\par

\def\mytable{%
\begin{tabular}{ |p{55mm}|p{65mm}|p{85mm}|}
 \hline
 Language & Java & Assumption for the project\\
IDE & Eclipse or NetBeans & Individual choice\\
Desktop & OS X, Windows, Linux & Individual Choice\\
JVM & Java version 7 & Awaiting input\\
Source and version control & GitHub & Agreed\\
Desktop source and version control & none specified, default is Git command line & Individual choice\\
Documentation & LaTeX & works well with GIT and is a academic standard\\
Informal Collaboration & Facebook & De facto standard\\
Testing & JUnit & The most widely used Java testing framework, simple to adopt\\
Test runner & To be decided & Nightly build and test sequence is desirable\\
Time Management & TFS and Gnatt chart & Gantt chart, WBS\\
 \hline
\end{tabular}
}
\scalebox{.78}{\mytable}

\clearpage
\pagebreak
\bibliography{csm24}{}
\bibliographystyle{ieeetr}

\end{document}
